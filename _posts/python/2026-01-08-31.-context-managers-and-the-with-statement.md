---
title: "31. Context Managers and the with Statement"
description: "üîß Master Python context managers for efficient resource management. Learn with statement, custom context managers, @contextmanager decorator, database connections, and best practices with real examples. üöÄ"
author: infoyouth
date: 2026-01-08 00:00:00 +0000
categories:
  - Programming
  - Python
  - Context Managers
  - Resource Management
tags:
  - Python
  - Context Managers
  - with Statement
  - Resource Management
  - Best Practices
---

<!--
meta-description: "üîß Master Python context managers for efficient resource management. Learn with statement, custom context managers, @contextmanager decorator, database connections, and best practices with real examples. üöÄ"
keywords: "Python context managers, with statement Python, __enter__ __exit__ methods, @contextmanager decorator, contextlib Python, resource management Python, file handling Python, database connection context manager, ExitStack Python, custom context managers, context manager best practices, Python resource cleanup, Python exception handling, SQLAlchemy context manager, Python context protocols"
-->

# <span style="color:#e67e22;">What we will learn in this post?</span>
<ul style='list-style-type: none; padding-left: 0;'>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Introduction to Context Managers</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Using with Statement</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Creating Custom Context Managers - Class-based</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Creating Context Managers with contextlib</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Nested Context Managers</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Context Managers for Database Connections</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Best Practices and Common Patterns</span></li>
</ul>

# <span style="color:#e67e22">Introduction to Context Managers and the `with` Statement in Python</span>

In Python, managing resources like files, locks, and connections can be tricky. That's where **context managers** and the `with` statement come in! üåü

## <span style="color:#2980b9">What are Context Managers?</span>

Context managers are special tools that help you manage resources efficiently. They ensure that resources are properly acquired and released, even if something goes wrong. 

### <span style="color:#8e44ad">Why Use the `with` Statement?</span>

Using the `with` statement makes your code cleaner and safer. Here‚Äôs why:

- **Automatic Cleanup**: Resources are released automatically when the block of code is done, even if an error occurs.
- **Simpler Syntax**: It reduces the amount of code you write for resource management.

### <span style="color:#8e44ad">Example of Using `with`</span>

```python
with open('file.txt', 'r') as file:
    content = file.read()
# No need to close the file manually!
```

### <span style="color:#2980b9">Benefits of Context Managers</span>

- **Prevents Resource Leaks**: Ensures that resources are not left open.
- **Improves Readability**: Makes your code easier to understand.

```mermaid
flowchart TD
    A["üöÄ Start"]:::style1 --> B{"üì¶ Resource Needed?"}:::style2
    B -- Yes --> C["üîì Acquire Resource"]:::style3
    C --> D["‚öôÔ∏è Use Resource"]:::style4
    D --> E["üîí Release Resource"]:::style5
    E --> F["‚úÖ End"]:::style1
    B -- No --> F

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

In summary, context managers and the `with` statement are essential for writing clean, efficient, and safe Python code! Happy coding! üéâ

# <span style="color:#e67e22">Understanding the `with` Statement in Python</span> üòä

The `with` statement in Python is a great way to manage resources like files. It helps you write cleaner code by automatically handling setup and cleanup tasks. 

## <span style="color:#2980b9">How It Works</span> üîç

When you use `with`, Python calls two special methods:

- **`__enter__`**: This method runs when you enter the `with` block. It prepares the resource.
- **`__exit__`**: This method runs when you leave the `with` block. It cleans up the resource.

### <span style="color:#8e44ad">Example: File Handling</span> üìÇ

**Using `with`:**

```python
with open('example.txt', 'r') as file:
    content = file.read()
# File is automatically closed here
```

**Without `with`:**

```python
file = open('example.txt', 'r')
content = file.read()
file.close()  # You must remember to close it!
```

### <span style="color:#8e44ad">Benefits of Using `with`</span> üåü

- **Automatic Cleanup**: No need to remember to close files.
- **Cleaner Code**: Less clutter and easier to read.
- **Error Handling**: Handles exceptions gracefully.


### <span style="color:#8e44ad">Flowchart of `with` Statement</span> üõ†Ô∏è

```mermaid
flowchart TD
    A["üöÄ Start"]:::style1 --> B["üì• Enter with block"]:::style2
    B --> C["üîß Call __enter__ method"]:::style3
    C --> D["‚ö° Execute block code"]:::style4
    D --> E["üîß Call __exit__ method"]:::style5
    E --> F["‚úÖ End"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

Using the `with` statement makes your code safer and more efficient. Happy coding! üéâ

# <span style="color:#e67e22">Creating Custom Context Managers with Classes</span>

## <span style="color:#2980b9">What is a Context Manager?</span>

A context manager in Python helps manage resources, like files or network connections, ensuring they are properly opened and closed. You can create custom context managers using classes by defining two special methods: `__enter__` and `__exit__`.

### <span style="color:#8e44ad">Defining `__enter__` and `__exit__`</span>

- **`__enter__`**: This method runs when you enter the context. It can set up resources and return values.
- **`__exit__`**: This method runs when you exit the context. It handles cleanup and can manage exceptions.

#### Parameters of `__exit__`:

- `self`: The instance of the class.
- `exc_type`: The type of exception raised (if any).
- `exc_value`: The value of the exception.
- `traceback`: The traceback object.

If you return `True` in `__exit__`, it suppresses the exception; otherwise, it will propagate.

## <span style="color:#2980b9">Practical Example</span>

Here‚Äôs a simple example of a context manager that manages a file:

```python
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            print(f"An error occurred: {exc_value}")
        self.file.close()

# Using the context manager
with FileManager('test.txt') as f:
    f.write('Hello, World!')
```

### <span style="color:#8e44ad">Key Points</span>

- **Resource Management**: Automatically handles opening and closing resources.
- **Error Handling**: Can manage exceptions gracefully.

### <span style="color:#2980b9">Conclusion</span>

Creating custom context managers is a powerful way to manage resources in Python. With just a few methods, you can ensure your resources are handled safely and efficiently! üòä

# <span style="color:#e67e22">Using @contextmanager for Easy Context Managers</span> üõ†Ô∏è

## <span style="color:#2980b9">What is @contextmanager?</span>

The `@contextmanager` decorator from the `contextlib` module helps you create context managers using generators. This makes it easy to manage resources like files or network connections. 

### <span style="color:#8e44ad">How Does It Work?</span>

When you use `@contextmanager`, you define a function that has a `yield` statement. This `yield` separates the **setup** and **teardown** code:

- **Setup**: Code before `yield` runs when entering the context.
- **Teardown**: Code after `yield` runs when exiting the context.

### <span style="color:#8e44ad">Example</span>

Here‚Äôs a simple example of using `@contextmanager`:

```python
from contextlib import contextmanager

@contextmanager
def open_file(file_name):
    try:
        f = open(file_name, 'r')
        yield f  # This is where the setup ends and the context begins
    finally:
        f.close()  # This runs when the context ends

# Using the context manager
with open_file('example.txt') as file:
    content = file.read()
    print(content)
```

### <span style="color:#2980b9">Key Points</span>

- **Easy to Use**: Simplifies resource management.
- **Automatic Cleanup**: Ensures resources are released properly.
- **Readable Code**: Makes your code cleaner and easier to understand.

```mermaid
flowchart TD
    A["üöÄ Start"]:::style1 --> B{"üéØ Using @contextmanager"}:::style2
    B --> C["üîß Setup Code"]:::style3
    C --> D["‚ö° Yield"]:::style4
    D --> E["üßπ Teardown Code"]:::style5
    E --> F["‚úÖ End"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

Happy coding! üéâ

# <span style="color:#e67e22">Handling Multiple Context Managers</span> üõ†Ô∏è

When working with files or resources in Python, **context managers** help manage them safely. You can use multiple `with` statements or `contextlib.ExitStack` for more flexibility. Let‚Äôs explore both methods!

## <span style="color:#2980b9">Using Multiple `with` Statements</span> üìÑ

You can nest `with` statements to handle multiple resources:

```python
with open('file1.txt') as f1, open('file2.txt') as f2:
    data1 = f1.read()
    data2 = f2.read()
```

This way, both files are opened and closed properly!

### <span style="color:#8e44ad">Benefits:</span>
- **Simplicity**: Easy to read and understand.
- **Safety**: Automatically closes resources.

## <span style="color:#2980b9">Using `contextlib.ExitStack`</span> üîÑ

For dynamic context management, `ExitStack` is your friend! It allows you to manage a variable number of context managers.

```python
from contextlib import ExitStack

with ExitStack() as stack:
    f1 = stack.enter_context(open('file1.txt'))
    f2 = stack.enter_context(open('file2.txt'))
    data1 = f1.read()
    data2 = f2.read()
```

### <span style="color:#8e44ad">Advantages:</span>
- **Flexibility**: Add or remove context managers easily.
- **Clean Code**: Keeps your code tidy.

### <span style="color:#2980b9">Visual Representation</span> üìä

```mermaid
graph TD;
    A["üöÄ Start"]:::style1 --> B["üìÇ Open File 1"]:::style2
    A --> C["üìÇ Open File 2"]:::style3
    B --> D["üìñ Read File 1"]:::style4
    C --> E["üìñ Read File 2"]:::style4
    D --> F["üîí Close File 1"]:::style5
    E --> G["üîí Close File 2"]:::style5

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">Using Context Managers for Database Connections</span> 

## <span style="color:#2980b9">What are Context Managers?</span>

Context managers help manage resources like database connections. They ensure that connections are properly opened and closed, making your code cleaner and safer. 

### <span style="color:#8e44ad">Example with SQLite</span>

Here's a simple example using SQLite:

```python
import sqlite3

def execute_query(query):
    with sqlite3.connect('example.db') as conn:
        cursor = conn.cursor()
        cursor.execute(query)
        conn.commit()  # Automatically commits changes
```

### <span style="color:#8e44ad">Example with SQLAlchemy</span>

SQLAlchemy makes it even easier with its session management:

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///example.db')
Session = sessionmaker(bind=engine)

with Session() as session:
    # Your database operations here
    session.add(new_record)
    session.commit()  # Automatically commits changes
```

## <span style="color:#2980b9">Benefits of Using Context Managers</span>

- **Automatic Resource Management**: No need to manually close connections.
- **Error Handling**: Rollbacks happen automatically on errors.
- **Cleaner Code**: Less boilerplate code to manage connections.

### <span style="color:#8e44ad">Flowchart of Connection Management</span>

```mermaid
flowchart TD
    A["üöÄ Start"]:::style1 --> B{"üîó Open Connection"}:::style2
    B -->|Yes| C["‚ö° Execute Query"]:::style3
    C --> D{"‚ùì Error?"}:::style4
    D -->|Yes| E["‚Ü©Ô∏è Rollback"]:::style5
    D -->|No| F["‚úÖ Commit"]:::style3
    F --> G["üîí Close Connection"]:::style5
    E --> G
    G --> H["üèÅ End"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

Using context managers makes your database interactions smooth and efficient! Happy coding! üòä

# <span style="color:#e67e22">Best Practices for Context Managers</span> üêç

Context managers in Python help manage resources efficiently. Here‚Äôs how to use them effectively!

## <span style="color:#2980b9">When to Use Context Managers</span> ‚è≥

- **Resource Management**: Use them for files, network connections, or database connections.
- **Temporary Changes**: Great for changing settings temporarily, like modifying environment variables.

## <span style="color:#2980b9">Ensuring `__exit__` Robustness</span> üîí

- Always handle exceptions in the `__exit__` method to ensure resources are released properly.
- Use `return True` to suppress exceptions if needed.

### <span style="color:#8e44ad">Example of `__exit__`</span>

```python
class MyContext:
    def __enter__(self):
        # Setup code
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        # Cleanup code
        if exc_type:
            print("Exception suppressed!")
            return True  # Suppress the exception
```

## <span style="color:#2980b9">Common Patterns</span> üìä

- **Timing**: Measure execution time of code blocks.
- **Logging**: Automatically log entry and exit of functions.
- **Temporary State Changes**: Change configurations temporarily and revert back.

### <span style="color:#8e44ad">Flowchart Example</span>

```mermaid
flowchart TD
    A["üöÄ Start"]:::style1 --> B{"ü§î Is resource needed?"}:::style2
    B -- Yes --> C["üîì Acquire resource"]:::style3
    C --> D["‚öôÔ∏è Use resource"]:::style4
    D --> E["üîí Release resource"]:::style5
    B -- No --> F["‚è≠Ô∏è Skip resource"]:::style4
    F --> E
    E --> G["‚úÖ End"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">Real-World Examples üåç</span>

## <span style="color:#2980b9">Example 1: Database Transaction Manager üíæ</span>

```python
from contextlib import contextmanager
import sqlite3

@contextmanager
def transaction(db_path):
    """Context manager for database transactions with automatic commit/rollback"""
    conn = sqlite3.connect(db_path)
    try:
        yield conn
        conn.commit()  # Commit if no exception
        print("‚úÖ Transaction committed successfully")
    except Exception as e:
        conn.rollback()  # Rollback on error
        print(f"‚ùå Transaction rolled back: {e}")
        raise
    finally:
        conn.close()

# Using the transaction manager
try:
    with transaction('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)",
                      ("Alice", "alice@example.com"))
        cursor.execute("UPDATE users SET active = 1 WHERE name = ?", ("Alice",))
        # Both operations committed together
except Exception as e:
    print(f"Failed to process user: {e}")
```

**Output:**
```
‚úÖ Transaction committed successfully
```

**Why This Matters:** Ensures database consistency by automatically rolling back all changes if any operation fails, preventing partial updates.

## <span style="color:#2980b9">Example 2: Temporary Directory Manager üìÅ</span>

```python
import os
import tempfile
import shutil
from contextlib import contextmanager

@contextmanager
def temporary_workspace():
    """Create a temporary directory that auto-cleans up"""
    temp_dir = tempfile.mkdtemp(prefix="workspace_")
    original_dir = os.getcwd()
    try:
        os.chdir(temp_dir)
        print(f"üìÇ Working in temporary directory: {temp_dir}")
        yield temp_dir
    finally:
        os.chdir(original_dir)
        shutil.rmtree(temp_dir)
        print(f"üßπ Cleaned up temporary directory")

# Using the temporary workspace
with temporary_workspace() as workspace:
    # Create files in temporary directory
    with open('temp_file.txt', 'w') as f:
        f.write('Temporary data')
    print(f"üìù Created file in: {os.getcwd()}")
    # Files automatically deleted when context exits

print(f"üè† Back to: {os.getcwd()}")
```

**Output:**
```
üìÇ Working in temporary directory: /tmp/workspace_abc123
üìù Created file in: /tmp/workspace_abc123
üßπ Cleaned up temporary directory
üè† Back to: /home/user/project
```

**Why This Matters:** Perfect for testing, data processing pipelines, or any operation requiring temporary files without manual cleanup.

## <span style="color:#2980b9">Example 3: Performance Timer Context Manager ‚è±Ô∏è</span>

```python
import time
from contextlib import contextmanager

@contextmanager
def timer(operation_name):
    """Measure execution time of code blocks"""
    start = time.time()
    print(f"‚è≥ Starting: {operation_name}")
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"‚úÖ {operation_name} completed in {elapsed:.3f} seconds")

# Using the timer
with timer("Data Processing"):
    # Simulate processing
    data = [i**2 for i in range(1000000)]
    result = sum(data)

with timer("Database Query"):
    time.sleep(0.5)  # Simulate query
    print("  üìä Fetched 1000 records")
```

**Output:**
```
‚è≥ Starting: Data Processing
‚úÖ Data Processing completed in 0.127 seconds
‚è≥ Starting: Database Query
  üìä Fetched 1000 records
‚úÖ Database Query completed in 0.502 seconds
```

**Why This Matters:** Simplifies performance profiling by automatically timing any code block without manual start/end time tracking.

## üß† Test Your Knowledge

{% include quiz.html
  question="What happens if an exception occurs inside a `with` block?"
  options="The program crashes immediately|The `__exit__` method is still called to clean up resources|Resources remain locked forever|The exception is automatically suppressed"
  correct="1"
  explanation="The `__exit__` method is always called, even when exceptions occur, ensuring proper resource cleanup. The exception is then re-raised unless `__exit__` returns True."
%}

{% include quiz.html
  question="What does the `yield` statement do in a @contextmanager decorated function?"
  options="Ends the function execution|Returns multiple values|Separates setup code from teardown code|Creates a generator object"
  correct="2"
  explanation="In @contextmanager, `yield` marks the transition point: code before yield runs on entry, and code after yield runs on exit, separating setup from cleanup logic."
%}

{% include quiz.html
  question="Which parameter of `__exit__` contains the exception type if an error occurred?"
  options="self|exc_type|exc_value|traceback"
  correct="1"
  explanation="The `exc_type` parameter contains the exception class (e.g., ValueError, IOError). It's None if no exception occurred in the with block."
%}

{% include quiz.html
  question="What is the advantage of using `contextlib.ExitStack` over nested `with` statements?"
  options="It's faster|It uses less memory|It allows dynamic management of variable numbers of context managers|It prevents all exceptions"
  correct="2"
  explanation="ExitStack shines when you don't know how many context managers you need at compile time. You can dynamically add them during runtime, unlike static nested with statements."
%}

{% include quiz.html
  question="What should `__exit__` return to suppress an exception?"
  options="None|False|True|The exception object"
  correct="2"
  explanation="Returning True from `__exit__` suppresses the exception, preventing it from propagating. Returning False (or None, which is falsy) allows the exception to propagate normally."
%}

---

<details style='border: 2px solid #ff9800; border-radius: 8px; padding: 20px; background: linear-gradient(135deg, #fff3e0 0%, #fff 100%); margin: 25px 0; box-shadow: 0 6px 12px rgba(255, 152, 0, 0.15);'>
<summary style='cursor: pointer; font-size: 1.3em; font-weight: bold; color: #ff9800; padding: 10px 0;'>
üéØ Hands-On Assignment: Build a Configuration Manager üöÄ
</summary>

<div style='margin-top: 20px; color: #2c3e50; line-height: 1.6;'>

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 20px;'>üìù Your Mission</h3>

Create a context manager that temporarily overrides application settings and automatically restores them when done, ensuring configuration consistency even when errors occur.

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 20px;'>üéØ Requirements</h3>

<ol style='margin-left: 20px;'>
<li>Create a class-based context manager called <code>ConfigurationOverride</code></li>
<li>The <code>__init__</code> method should accept a config dictionary and new overrides</li>
<li>In <code>__enter__</code>, save the original config values and apply overrides</li>
<li>In <code>__exit__</code>, restore the original configuration values
  <ul style='margin-left: 20px; margin-top: 8px;'>
    <li>Handle exceptions properly</li>
    <li>Always restore original settings regardless of errors</li>
  </ul>
</li>
<li>Test with different configuration scenarios</li>
</ol>

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 25px;'>üí° Implementation Hints</h3>

<ol style='margin-left: 20px;'>
<li>Use <code>self.original_values = {}</code> to store original configuration</li>
<li>In <code>__enter__</code>, iterate through overrides and save originals before applying</li>
<li>Return <code>self</code> from <code>__enter__</code> to enable <code>with ... as var</code> syntax</li>
<li>In <code>__exit__</code>, restore each saved value from <code>self.original_values</code></li>
<li>Don't suppress exceptions - return <code>None</code> or <code>False</code> from <code>__exit__</code></li>
</ol>

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 25px;'>üöÄ Example Input/Output</h3>

<pre style='background: #2c3e50; color: #ecf0f1; padding: 20px; border-radius: 8px; overflow-x: auto; margin: 15px 0;'><code class='language-python'>app_config = {'debug': False, 'max_connections': 10, 'timeout': 30}

print(f"Original config: {app_config}")
# Original config: {'debug': False, 'max_connections': 10, 'timeout': 30}

with ConfigurationOverride(app_config, debug=True, timeout=60):
    print(f"Inside context: {app_config}")
    # Inside context: {'debug': True, 'max_connections': 10, 'timeout': 60}

print(f"After context: {app_config}")
# After context: {'debug': False, 'max_connections': 10, 'timeout': 30}
</code></pre>

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 25px;'>üèÜ Bonus Challenges</h3>

<ul style='margin-left: 20px;'>
<li><strong>Level 2</strong>: Add support for nested configuration dictionaries</li>
<li><strong>Level 3</strong>: Create the same functionality using <code>@contextmanager</code> decorator</li>
<li><strong>Level 4</strong>: Add validation to ensure override keys exist in original config</li>
<li><strong>Level 5</strong>: Implement a context manager that tracks all configuration changes with timestamps</li>
</ul>

<h3 style='color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 8px; margin-top: 25px;'>üìö Learning Goals</h3>

<ul style='margin-left: 20px;'>
<li>Understand <code>__enter__</code> and <code>__exit__</code> lifecycle üéØ</li>
<li>Practice proper resource restoration ‚ú®</li>
<li>Learn exception handling in context managers üîÑ</li>
<li>Compare class-based vs decorator-based approaches üîó</li>
<li>Master temporary state management patterns üõ†Ô∏è</li>
</ul>

<p style='background: #3498db; color: #fff; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 5px solid #2980b9;'>
<strong>üí° Pro Tip:</strong> This pattern is used in Django's <code>override_settings</code> and pytest's fixture management!
</p>

<p style='margin-top: 20px; font-size: 1.1em;'><strong>Share Your Solution! üí¨</strong></p>
<p>Completed the project? <strong>Post your code in the comments below!</strong> Show us your Python context manager mastery! üöÄ‚ú®</p>

</div>
</details>

---

# <span style="color:#e67e22">Conclusion üéì</span>

Context managers are essential for writing clean, safe Python code by automating resource management through the `with` statement and special methods like `__enter__` and `__exit__`. Mastering patterns like `@contextmanager`, `ExitStack`, and custom implementations ensures your applications handle files, databases, and system resources efficiently without leaks or errors.
