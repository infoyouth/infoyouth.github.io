---
title: "07. Structs and Methods"
description: "🚀 Master Go's structs and methods! Learn how to define structs, leverage embedded fields, understand method sets, and use struct tags effectively. This post empowers you to build robust and organized Go applications. ✨"
author: infoyouth
date: 2025-10-26 02:00:00 +0000
categories:
  - Programming
  - Go
  - Structs and Methods
tags:
  - "Go Programming"
  - "Struct Definition"
  - "Methods"
  - "Pointer Receivers"
  - "Struct Tags"
pin: true
math: false
mermaid: true
---

# <span style="color:#e67e22;">What we will learn in this post?</span>
<ul style='list-style-type: none; padding-left: 0;'>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Defining Structs</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Anonymous Structs and Embedded Fields</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Methods in Go</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Pointer vs Value Receivers</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Method Sets</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Struct Tags</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>👉</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Conclusion!</span></li>
</ul>

# <span style="color:#e67e22">Structs in Go 🚀</span>

Go structs are like blueprints for creating custom data types. They bundle together different fields, each with its own type.

## <span style="color:#2980b9">Defining Structs 📝</span>

To define a struct, we use the `type` keyword followed by the struct's name and the `struct` keyword, and then list the fields and their types within curly braces:

```go
type Person struct {
    Name string
    Age  int
}
```

Here, `Person` is a struct with two fields: `Name` (a string) and `Age` (an integer).

## <span style="color:#2980b9">Initializing Structs ✨</span>

We can initialize structs in a few ways:

*   **Struct Literals:**

```go
person1 := Person{"Alice", 30} // Order matters!
```

*   **Field: Value Syntax:**

```go
person2 := Person{Name: "Bob", Age: 25} // Order doesn't matter!
```

*   **`new()` Function:**

```go
person3 := new(Person) // Returns a pointer to a zero-valued Person
person3.Name = "Charlie"
person3.Age = 40
```

## <span style="color:#2980b9">Nested Structs 🏠</span>

Structs can contain other structs as fields, creating nested structures:

```go
type Address struct {
    Street string
    City   string
}

type Employee struct {
    Name    string
    Address Address // Nested struct
}

employee1 := Employee{Name: "David", Address: Address{Street: "123 Main St", City: "Anytown"}}
```

*   More details and advanced struct concepts can be found in the [official Go documentation](https://go.dev/tour/moretypes/2).
*   Tutorialspoint also provides a good resource for structs [Tutorialspoint](https://www.tutorialspoint.com/go/go_structures.htm)


# <span style="color:#e67e22">Structs in Go: One-Time Use & Composition 🧩</span>

Let's explore structs in Go, focusing on *anonymous structs* for one-off situations and *struct embedding* for building complex types.

## <span style="color:#2980b9">Anonymous Structs 👻</span>

Anonymous structs are defined without a name and are useful when you need a struct type *only once*.

```go
package main

import "fmt"

func main() {
    person := struct {
        Name string
        Age  int
    }{
        Name: "Alice",
        Age:  30,
    }

    fmt.Println(person) // Output: {Alice 30}
}
```

## <span style="color:#2980b9">Struct Embedding: Composition over Inheritance 🏗️</span>

Go doesn't have inheritance in the traditional sense. Instead, it uses *struct embedding* which provides a powerful *composition* mechanism.

```go
package main

import "fmt"

type Address struct {
    Street string
    City   string
}

type Employee struct {
    ID   int
    Address // Embedded field
}

func main() {
    emp := Employee{
        ID: 123,
        Address: Address{
            Street: "1 Main St",
            City:   "Anytown",
        },
    }

    fmt.Println(emp.Street) // **Promoted field!** Output: 1 Main St
    fmt.Println(emp.Address.City) //Output: Anytown
}
```

*   **Embedded Fields:** `Address` is embedded in `Employee`.
*   **Promotion:** Fields from the embedded struct are *promoted* to the outer struct.  So `emp.Street` directly accesses the `Street` field of the embedded `Address` struct.

### <span style="color:#8e44ad">Composition vs. Inheritance ⚖️</span>

*   **Composition:** Creates a "has-a" relationship. `Employee` *has an* `Address`. It's flexible and avoids the tight coupling of inheritance.
*   **Inheritance:** Creates an "is-a" relationship.  Not directly supported in Go.  Composition provides the benefits of code reuse without the complexities of inheritance hierarchies.

Instead of thinking of `Employee` *inheriting* from `Address`, think of `Employee` *containing* an `Address` and conveniently providing direct access to its fields. Check out this [awesome blog](https://www.ardanlabs.com/blog/2017/06/oop-is-dead-long-live-composition.html) to know more.


# <span style="color:#e67e22">Methods on Structs in Go ⚙️</span>

Go lets you add *behaviors* to your `struct` types using methods. Think of it like giving your data abilities!

## <span style="color:#2980b9">Defining Methods with Receiver Functions 🤝</span>

The magic happens with a **receiver function**. Here's how it looks:

```go
func (r MyStruct) MyMethod() {
  // Your code here, accessing fields of 'r'
}
```

*   `func`:  Keyword for defining a function.
*   `(r MyStruct)`:  The *receiver*. `r` is a variable (like `this` or `self` in other languages) that refers to an instance of `MyStruct`.
*   `MyMethod()`: The name of your method.

## <span style="color:#2980b9">Calling Methods and Chaining 📞🔗</span>

You call methods using the `.` operator:

```go
myVar := MyStruct{ /* ... */ }
myVar.MyMethod()
```

If a method returns a value that allows you to call another method on it directly, you can use **method chaining**:

```go
result := myVar.Method1().Method2().Method3()
```

**Example:**

```go
type Rectangle struct {
    Width  int
    Height int
}

func (r Rectangle) Area() int {
    return r.Width * r.Height
}

func main() {
    myRect := Rectangle{Width: 10, Height: 5}
    area := myRect.Area() // calling the Area method.
    println(area) // output is 50
}
```
[More Info](https://go.dev/tour/methods/1)


# <span style="color:#e67e22">Pointer vs. Value Receivers in Go 🛠️</span>

In Go, methods can have either **pointer receivers** (`*T`) or **value receivers** (`T`). This choice impacts how the method interacts with the underlying data. Let's break it down!

## <span style="color:#2980b9">Understanding the Difference 🧐</span>

*   **Value Receiver (T):** The method operates on a *copy* of the original struct. Changes made inside the method *do not* affect the original struct. Think of it like making a photocopy and editing it. 📝

*   **Pointer Receiver (*T):** The method operates directly on the *original* struct. Changes made inside the method *do* affect the original struct. Think of it like directly editing a document. 💻

## <span style="color:#2980b9">When to Use Which? 🤔</span>

*   **Mutation (Changing Data):** Use a pointer receiver (`*T`) if the method needs to *modify* the struct's fields. If we want to save the changes. ✅
*   **Read-Only (No Changes):** Use a value receiver (`T`) if the method only needs to *read* the struct's fields and *doesn't* modify them. 📖
*   **Large Structs (Performance):** Use a pointer receiver (`*T`) for large structs to avoid copying the entire struct every time the method is called. This can significantly improve performance. 🚀

## <span style="color:#2980b9">Go's Magic: Automatic Conversions ✨</span>

Go automatically handles conversions. You can call a method with a pointer receiver on a value, and Go will automatically take the address. Similarly, you can call a method with a value receiver on a pointer, and Go will automatically dereference it.

## <span style="color:#2980b9">Comparative Examples 💡</span>

```go
type Circle struct {
    Radius int
}

// Value receiver - Doesn't modify the original.
func (c Circle) AreaValue() int {
    c.Radius = 100 // This DOES NOT affect the original circle
    return c.Radius * c.Radius
}

// Pointer receiver - Modifies the original.
func (c *Circle) DoubleRadius() {
    c.Radius = c.Radius * 2 // This affects the original circle.
}

func main() {
    myCircle := Circle{Radius: 5}

    area := myCircle.AreaValue() //Calls area value on value reciever
	println("Area:",area)       //prints 10000 since value reciever works on a copy.

    myCircle.DoubleRadius()
    println("Radius:", myCircle.Radius) //prints Radius 10
}
```

## <span style="color:#8e44ad">Summary</span>

*   `Value Reciever` Use if you only have to read the data.
*   `Pointer Reciever` Use if you have to read and modify the data.

---
[Resources on GO programming](https://go.dev/)



Here's an explanation of method sets in Go, designed to be friendly and easy to understand!

# <span style="color:#e67e22">Method Sets in Go: 🧐 What Are They?</span>

Method sets determine which methods a type has. This is super important for interfaces!

## <span style="color:#2980b9">Value vs. Pointer Receivers</span>

*   A _value receiver_ gets a copy of the value. Both a `T` and `*T` (pointer to `T`) can call these methods.
*   A _pointer receiver_ gets the actual value's address. Only `*T` can directly call these methods. A `T` can call it if Go can automatically get its address.

## <span style="color:#2980b9">Interface Satisfaction and Method Sets</span>

A type satisfies an interface if its method set includes all the interface's methods.

*   If an interface has pointer receiver methods, only a `*T` can satisfy it.
*   If an interface has value receiver methods, both `T` and `*T` can satisfy it.

```go
type MyInterface interface {
  MethodWithPointerReceiver()
}

type MyType struct {}

func (t *MyType) MethodWithPointerReceiver() {} // *MyType implements MyInterface

func main() {
  var i MyInterface
  mt := MyType{}
  i = &mt // Correct!
  //i = mt  // Error: MyType does not implement MyInterface (MethodWithPointerReceiver has pointer receiver)
}
```

## <span style="color:#2980b9">Example: Seeing it in Action 🚀</span>

```go
type Number int

// Value receiver
func (n Number) String() string {
  return fmt.Sprintf("Value: %d", n)
}

// Pointer receiver
func (n *Number) Increment() {
  *n++
}

func main() {
  num := Number(5)
  fmt.Println(num.String())   // Works: Value receiver can be called on value
  (&num).Increment()      // Works: Pointer receiver called on pointer
  fmt.Println(num.String())
}
```

In the example:

*   `String()` is in the method set of both `Number` and `*Number`.
*   `Increment()` is only in the method set of `*Number`.
*   <ins>More Info</ins>: Check out this article about method sets. [Go Method Sets](https://go.dev/tour/methods/4)


Here's a friendly explanation of struct tags in Go:

# <span style="color:#e67e22">Struct Tags Explained 🏷️</span>

Struct tags are little pieces of metadata you can add to the fields of a struct in Go. They're written inside backticks `` ` `` after the field's type. Think of them as instructions for tools like JSON encoders, validators, or database mappers.

## <span style="color:#2980b9">What are they for? 🤔</span>

*   **JSON Marshaling (`json:"name"`)**:  Tells the `json` package how to name a field when encoding to JSON.  For example: `FieldName string `json:"field_name"` `` will make the JSON key `field_name`.

*   **Validation**:  Libraries can use tags to define validation rules. `Name string `validate:"required,min=3"` `` might specify that `Name` must not be empty and have at least 3 characters.

*   **Database ORM Mapping**:  Help ORMs (Object-Relational Mappers) map struct fields to database columns.  `ID int `db:"user_id,primarykey"` `` could indicate that the `ID` field corresponds to the `user_id` column and is a primary key.

## <span style="color:#8e44ad">How to Use Them? 🚀</span>

```go
type User struct {
    ID   int    `json:"id" db:"user_id,primarykey"`
    Name string `json:"name" validate:"required"`
}
```

*   **Syntax**:  `FieldName Type `tag1:"value1" tag2:"value2"` `

*   **Accessing Tags**: You need to use *reflection* to read tag values at runtime:

```go
package main

import (
	"fmt"
	"reflect"
)

type Person struct {
	Name string `json:"name,omitempty" validate:"required"`
	Age  int    `json:"age"`
}

func main() {
	personType := reflect.TypeOf(Person{})

	for i := 0; i < personType.NumField(); i++ {
		field := personType.Field(i)
		jsonTag := field.Tag.Get("json")
		validateTag := field.Tag.Get("validate")

		fmt.Printf("Field: %s, JSON Tag: %s, Validate Tag: %s\n", field.Name, jsonTag, validateTag)
	}
}
```

This code snippet shows how to inspect the tags of a struct's fields. The `reflect` package is used to get the type information of the struct and then iterate over its fields. For each field, the `Tag.Get` method is used to retrieve the value of the `json` and `validate` tags.
[Reflection in Go](https://go.dev/reflect)
## <span style="color:#8e44ad">Practical example 💡</span>
```go
package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	ID     int    `json:"id"`
	Name   string `json:"user_name"`
	Email  string `json:"email,omitempty"` // omitempty: will hide if email is ""
	passwd string `json:"-"`             //-: will hide password
}

func main() {
	user := User{ID: 1, Name: "John Doe", Email: "john.doe@example.com", passwd: "securePassword"}

	jsonData, err := json.Marshal(user)
	if err != nil {
		fmt.Println("Error marshaling JSON:", err)
		return
	}

	fmt.Println(string(jsonData))
}
```
output:
```json
{"id":1,"user_name":"John Doe","email":"john.doe@example.com"}
```
Here, the Name Field in Json will be `user_name`, Email will hide when empty and passwd will hide.
<br>

Tags offer a powerful way to customize how Go structs interact with external systems and libraries, making your code more flexible and expressive.


Okay, here are a few different conclusion statements you can use, all formatted as requested:

**Option 1:**

<h1><span style='color:#e67e22'>Conclusion</span></h1>

Well, that's a wrap! I hope you found this helpful. Now it's your turn! I'm super curious to hear your thoughts, experiences, or maybe even some tips of your own! Don't be shy – drop a comment below and let's chat! 💬 Your feedback is gold! ✨
**Option 2:**

<h1><span style='color:#e67e22'>Conclusion</span></h1>

And there you have it! I really enjoyed sharing this with you. What are your takes? Did anything resonate with you? Leave a comment below and let me know! 🤔 I'm always looking for new ideas and perspectives. Let's learn from each other! 📚
**Option 3:**

<h1><span style='color:#e67e22'>Conclusion</span></h1>

Alright, we've reached the end! 😊 I'm really keen to know what *you* think. Any comments, questions, or suggestions? Please share them below! Your input helps make this even better. 👇 Looking forward to reading them! 🚀
**Option 4:**

<h1><span style='color:#e67e22'>Conclusion</span></h1>

So that brings us to the end! I'm dying to hear your perspective. What are your favorite tips or experiences related to this? Spill the beans in the comments! ✍️ Your insights are greatly appreciated! 🙏
**Option 5:**

<h1><span style='color:#e67e22'>Conclusion</span></h1>

We've reached the finish line! 🏁 Now it's over to you! Share your comments, questions or anything you'd like to add below. Let's create a real discussion! 🎉


