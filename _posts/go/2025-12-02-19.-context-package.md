---
title: "19. Context Package"
description: "üöÄ Dive deep into Go's essential Context package! Master its basics, creation, values, and vital cancellation patterns to build robust, concurrent applications and handle HTTP requests effectively. ‚úÖ"
author: infoyouth
date: 2025-12-02 02:00:00 +0000 02:00:00 +0000
categories:
  - Programming
  - Go
  - Concurrency
  - Context Management
  - Web Development
tags:
  - Go
  - context.Context
  - Concurrency
  - Cancellation
  - HTTP API
pin: true
math: false
mermaid: true
---

<!--
meta-description: "Master Go's context package! Learn context basics, creation with Background/WithCancel/WithTimeout, passing values, cancellation patterns, HTTP request contexts, and best practices for building robust concurrent applications."
keywords: "Go context package, context.Context, context.WithCancel, context.WithTimeout, context.WithValue, cancellation patterns, goroutine management, HTTP context, request lifecycle, concurrent programming Go, context best practices"
-->

# <span style="color:#e67e22;">What we will learn in this post?</span>
<ul style='list-style-type: none; padding-left: 0;'>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Context Basics</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Creating Contexts</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Context Values</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Cancellation Patterns</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Context in HTTP</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Context Best Practices</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Conclusion!</span></li>
</ul>

# <span style="color:#e67e22">üì¶ Understanding Go's `context` Package</span>

The `context` package in Go carries crucial signals like deadlines, cancellation requests, and request-specific values across function boundaries. This messenger travels with your operations, ensuring goroutines can respond to timeouts and cancellations gracefully.

## <span style="color:#2980b9">üöÄ Why `context` is Crucial for Concurrent & HTTP Apps</span>

`context` is vital for managing concurrent tasks and HTTP requests gracefully.

*   **Concurrent Programs:** If you launch many goroutines, and the main task is canceled or times out, the `context` allows you to *efficiently signal* all related goroutines to stop, preventing resource leaks and wasted effort.
*   **HTTP Servers:** When a client makes a request, an HTTP server starts a `context`. If the client disconnects or the request exceeds a timeout, the `context` can *automatically cancel* ongoing database queries or downstream API calls, cleaning up resources.

### <span style="color:#8e44ad">üí° Basic Examples & How it Works</span>

You typically start with a `context.Background()` or `context.TODO()` and then derive new contexts:

*   `context.WithTimeout(parent, duration)`: Sets a deadline.
*   `context.WithCancel(parent)`: Creates a cancellable context.
*   `context.WithValue(parent, key, value)`: Adds request-scoped data.

Functions check `ctx.Done()` or `ctx.Err()` to react to cancellation or timeouts.

```mermaid
graph TD
    A["HTTP Request Starts"]:::style1 --> B["Initial Context"]:::style2
    B -- "Add Timeout (e.g., 5s)" --> C["Timeout Context"]:::style3
    C -- "Add User ID" --> D["Value Context"]:::style4
    D --> E["Perform Database Query"]:::style5
    E -- "If ctx.Done() or ctx.Err()" --x F["Stop Query & Return Error"]:::style1
    E --> G["Return Query Result"]:::style5

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">Understanding Go's Context Creation Functions</span>

Go's `context` package provides essential functions for managing deadlines, cancellations, and request-scoped values across goroutines. These creation functions form the foundation of robust concurrent applications.

---

## <span style="color:#2980b9">`context.Background()` üå≥</span>

This is the *root* context for your program. It's never canceled, has no deadline, and no values. Use it as the starting point for your `main` function, initial requests, or tests where no parent context exists.

```go
import "context"

ctx := context.Background()
// Use ctx for your top-level operations
```

---

## <span style="color:#2980b9">`context.TODO()` ü§î</span>

A placeholder context when you're unsure which context to use or if code needs refactoring. Similar to `Background()`, it signals to developers that context usage needs improvement. ***Avoid* using it in production code!**

```go
import "context"

ctx := context.TODO() // Placeholder, needs proper context later!
// ... code that will eventually be refactored
```

---

## <span style="color:#2980b9">`context.WithCancel()` üõë</span>

```mermaid
graph TD
    A["Parent Context"]:::style1 --> B{"context.WithCancel(Parent)"}:::style2
    B --> C["New Context & CancelFunc"]:::style3
    C -- "Use Context in Goroutines" --> D["Worker Goroutine 1"]:::style4
    C --> E["Worker Goroutine 2"]:::style5
    F["Call CancelFunc()"]:::style1 --> G["New Context Done() channel closes"]:::style3
    G --> H["Goroutines (D, E) detect cancellation & exit cleanly"]:::style4

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

This function creates a child context that can be *explicitly canceled*. You receive a new `Context` and a `CancelFunc`. Calling `CancelFunc` will stop all goroutines listening to this context or its children, which is useful for graceful shutdowns.

```go
import (
	"context"
	"time"
)

ctx, cancel := context.WithCancel(context.Background())
defer cancel() // Always call cancel to release resources!

go func() {
	select {
	case <-time.After(5 * time.Second):
		fmt.Println("Operation completed without cancellation.")
	case <-ctx.Done():
		fmt.Println("Operation canceled!")
	}
}()
// In another part of your code, you might call cancel()
// cancel() // Uncomment to test immediate cancellation
time.Sleep(2 * time.Second) // Give goroutine time to start
```

---

## <span style="color:#2980b9">`context.WithTimeout()` / `WithDeadline()` ‚è≥</span>

These functions create a child context that *automatically cancels* after a specific time.

*   **`context.WithTimeout(parent, duration)`**: Cancels after a `time.Duration`.
*   **`context.WithDeadline(parent, time.Time)`**: Cancels at an exact `time.Time`.

They are great for enforcing maximum execution times for network requests or computations.

```go
import (
	"context"
	"time"
	"fmt"
)

// Example with WithTimeout
ctxTimeout, cancelTimeout := context.WithTimeout(context.Background(), 2*time.Second)
defer cancelTimeout() // Don't forget to call cancel!

select {
case <-time.After(3 * time.Second):
	fmt.Println("Operation finished before timeout (should not happen here).")
case <-ctxTimeout.Done():
	fmt.Println("Operation timed out:", ctxTimeout.Err()) // Prints "context deadline exceeded"
}
```

---


# <span style="color:#e67e22">Passing Request Data with `context` in Go üì¶</span>

Go's `context.Context` provides `WithValue()` and `Value()` for safely passing request-scoped data like user IDs or trace IDs throughout a request's lifecycle. This pattern enables clean data flow without polluting function signatures.

---

## <span style="color:#2980b9">Adding Data with `context.WithValue()` üëã</span>

`context.WithValue()` creates a *new context* derived from an existing one, embedding a *key-value pair*. This data then flows down the call chain. The `key` should ideally be an **unexported struct type** to prevent collisions across different packages.

```go
package main

import (
	"context"
	"fmt"
)

// Define a private key type to avoid collisions
type userIDKey struct{} 

func main() {
	parentCtx := context.Background()
	
	// Add a user ID to the context
	ctx := context.WithValue(parentCtx, userIDKey{}, "user-12345") 
	
	// 'ctx' now carries the user ID
	fmt.Println("User ID added to context!")
}
```

---

## <span style="color:#2980b9">Retrieving Data with `context.Value()` üïµÔ∏è‚Äç‚ôÄÔ∏è</span>

To get the data back, you use `ctx.Value()` with the *same key* that was used to store it. Remember to perform a **type assertion** and check if the value exists (`ok` variable) to handle cases where the data might not be present or is of a different type.

```go
// Inside a function deeper in the call chain...
func processRequest(ctx context.Context) {
    userID, ok := ctx.Value(userIDKey{}).(string) // Type assertion
    if !ok {
        fmt.Println("User ID not found in context.")
        return
    }
    fmt.Printf("Processing request for User ID: %s\n", userID)
}
// Call in main: processRequest(ctx)
```

---

## <span style="color:#2980b9">Best Practices & Anti-Patterns ‚úÖ‚ùå</span>

*   **‚úÖ Use for:** *Request-scoped data* that all downstream functions might need (e.g., authenticated user ID, trace ID, deadline, session data). It‚Äôs data that defines the *current operational context*.
*   **‚ùå Avoid for:** *Optional function parameters*. If a function needs specific data, pass it explicitly as an argument. Using `context.Value()` for optional parameters makes function signatures unclear and difficult to test.
*   **Key Type:** Always use an **unexported, distinct type** (like our `userIDKey` struct) for your context keys. This prevents accidental conflicts if multiple packages try to use the same string or basic type as a key.

```mermaid
graph TD
    A["Incoming HTTP Request"]:::style1 --> B{"Middleware: Authenticate & Add User ID"}:::style2
    B -- "Add User ID to context" --> C["Service Layer: processUserRequest(ctx)"]:::style3
    C -- "Pass context" --> D["Repository Layer: getUserData(ctx, userID)"]:::style4
    D -- "Retrieve User ID from context" --> E["Database Query"]:::style5
    E --> F["Response"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">Graceful Cancellation in Go: The Polite Stop! ‚úÖ</span>

When your Go program needs to stop a running task, `context` enables graceful cancellation by sending signals to goroutines. This allows operations to clean up resources and exit smoothly instead of abruptly terminating.

## <span style="color:#2980b9">Listening for the Signal &#x1F4E1;</span>

Inside `goroutines`, you periodically check `_ctx.Done()_`. This is a channel that closes when cancellation is requested. Use a `select` statement to listen for it alongside your operation's result. When `<-ctx.Done()` receives a value, it means "cancel now!"

```go
select {
case <-ctx.Done(): // Cancellation signal received!
    return ctx.Err() // Return the cancellation reason
case result := <-someOperationChan:
    // Handle normal operation result
    return nil
}
```

## <span style="color:#2980b9">Handling Long Operations &#x23F1;&#xFE0F;</span>

For *long-running operations* (like network requests or complex calculations), ensure they accept a `context`. If the operation is internal, break it into smaller, interruptible steps. After each step, check `ctx.Done()`. If cancelled, stop processing, perform necessary *cleanup*, and return.

## <span style="color:#2980b9">Passing the Word Down &#x1F33F;</span>

A parent `goroutine` can create a child context using `context.WithCancel(parentCtx)`. When the parent calls its `cancel()` function, this signal *automatically propagates* down to all child `goroutines` using that context, and even their children. This creates a cancellation *tree*.

```mermaid
graph TD
    A["Parent Goroutine"]:::style1 -- "Creates context.WithCancel" --> B["Parent Context + Cancel Func"]:::style2
    B -- "Passes Context To" --> C["Child Goroutine 1"]:::style3
    B -- "Passes Context To" --> D["Child Goroutine 2"]:::style4
    B -- "Calls cancel() Func" --> A
    A -- "Triggers Cancellation" --> C
    A -- "Triggers Cancellation" --> D
    C -- "Checks ctx.Done()" --> E["Stops Gracefully"]:::style5
    D -- "Checks ctx.Done()" --> F["Stops Gracefully"]:::style5

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```


# <span style="color:#e67e22">`r.Context()` & Request Lifecycles üåê</span>

Every incoming HTTP request in Go comes with a `Context` accessible via `r.Context()`, carrying timeouts, cancellation signals, and request-scoped values. This context automatically propagates through your application's layers and cancels when clients disconnect.

## <span style="color:#2980b9">Why Use `r.Context()`? ü§î</span>

Using `**r.Context()**` is crucial for managing your server's health and responsiveness:

*   **Timeouts**: Ensures operations don't run forever.
*   **Cancellation Signals**: Tells long-running tasks to stop if they're no longer needed.
*   **Resource Management**: Prevents wasted work and server load.

### <span style="color:#8e44ad">Passing Context Downstream ‚¨áÔ∏è</span>

When your server-side Go handler needs to interact with other services, like a *database* or an *external API*, you should **always** pass the request's context along. This propagates the request's original boundaries and signals.

*   **Example (Database Query):**
    ```go
    rows, err := db.QueryContext(r.Context(), "SELECT * FROM users WHERE id = $1", userID)
    ```
*   **Example (External API Call):**
    ```go
    req, _ := http.NewRequestWithContext(r.Context(), "GET", "https://api.example.com/data", nil)
    resp, err := http.DefaultClient.Do(req)
    ```
This tells your downstream operations to respect the original client's request.

### <span style="color:#8e44ad">Automatic Cancellation Magic ‚ú®</span>

The coolest part? If the client who made the request suddenly *disconnects* (e.g., closes their browser or app), the Go server **automatically cancels** the associated `_Context_`. Any pending database queries or API calls that received this context will then be notified to stop gracefully. This saves server resources and prevents unnecessary work.

```mermaid
graph TD
    A["Client Request Arrives"]:::style1 --> B{"HTTP Handler 'r'"}:::style2
    B --> C{"r.Context() created"}:::style3
    C --> D["Context Passed to DB Calls"]:::style4
    C --> E["Context Passed to External API Calls"]:::style5
    D -- "Client Disconnects" --> F["DB Query Cancels"]:::style1
    E -- "Client Disconnects" --> G["API Call Cancels"]:::style1
    F & G --> H["Server Saves Resources"]:::style3

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

---

# <span style="color:#e67e22">Understanding Go's `context` üöÄ</span>

Go's `context` package is essential for managing cancellation signals, deadlines, and request-scoped values across API boundaries. Following best practices ensures robust, responsive applications that handle resource cleanup properly.

## <span style="color:#2980b9">Context Best Practices ‚ú®</span>

### <span style="color:#8e44ad">Pass as First Parameter ‚û°Ô∏è</span>
*Always pass* `context.Context` *as the first argument* to functions that might need it. This makes it explicit that the function respects cancellation and can carry request-scoped data. E.g., `func MyFunc(ctx context.Context, itemID string)`.

### <span style="color:#8e44ad">No Storing in Structs üö´</span>
*Do not store* `Context` *within struct fields*. Instead, pass it directly to the methods that require it. Storing it can lead to confusion, unexpected cancellations, or using an outdated context.

### <span style="color:#8e44ad">Derive Child Contexts üå≥</span>
When you initiate new goroutines or distinct operations, *derive new contexts* from the *parent context*. Use `context.WithCancel`, `context.WithTimeout`, or `context.WithValue` to build a clear cancellation hierarchy and propagate necessary values.

```mermaid
graph TD
    A["Parent Context"]:::style1 --> B["Child Context: WithCancel"]:::style2
    A --> C["Child Context: WithTimeout"]:::style3
    A --> D["Child Context: WithValue"]:::style4

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

### <span style="color:#8e44ad">Handle `ctx.Done()` üõë</span>
For *long-running operations* (e.g., loops, blocking calls), *always check `ctx.Done()`*. Use a `select` statement to listen for the cancellation signal. This allows your operation to clean up and exit gracefully, preventing resource leaks and ensuring responsiveness.

## <span style="color:#2980b9">Common Pitfalls to Avoid ‚ö†Ô∏è</span>
*   **Ignoring `ctx.Done()`:** Failing to check for cancellation can leave goroutines running indefinitely, leading to resource leaks and unresponsive services.
*   **Storing `Context` in Structs:** This is a common anti-pattern that violates the explicit passing principle and can introduce subtle bugs.
*   **Blindly Using `context.TODO()`:** Use `context.Background()` at your application's top level. `context.TODO()` is merely a placeholder until you determine the correct context.

---

<details>
<summary><strong style="font-size: 1.5em; color:#ff4f81;">üéØ Hands-On Assignment</strong></summary>
<br>

Ready to master context management? Complete this assignment and share your implementation in the comments below!

### üìã Problem Statement

Build a **Concurrent Task Processor** that demonstrates context usage for timeouts, cancellation, and request-scoped values. Your system should process multiple tasks concurrently while respecting deadlines and handling graceful shutdowns.

### ‚úÖ Requirements

Create a concurrent task processing system with:

1. **Task struct:**
   - `ID` (string)
   - `Name` (string)
   - `Duration` (time.Duration - simulated processing time)
   - `Priority` (int)

2. **Core functionality:**
   - Process multiple tasks concurrently using goroutines
   - Each task must accept and respect `context.Context`
   - Implement timeout for individual tasks (5 seconds max)
   - Support graceful shutdown on SIGINT/SIGTERM
   - Pass request ID through context for tracing
   - Cancel all running tasks when main context is canceled

3. **Context patterns to demonstrate:**
   - `context.WithTimeout()` for task deadlines
   - `context.WithCancel()` for manual cancellation
   - `context.WithValue()` for request ID propagation
   - Proper `ctx.Done()` checking in long-running operations

### üí° Implementation Hints

1. Use `context.Background()` as root context in main
2. Create task-specific contexts with `context.WithTimeout()`
3. Use `select` statement to listen for `ctx.Done()` and task completion
4. Implement signal handling with `signal.Notify()` for graceful shutdown
5. Use `sync.WaitGroup` to wait for all goroutines to complete
6. Create custom context key type for request ID (avoid string keys)
7. Check `ctx.Err()` to determine cancellation reason (timeout vs manual)
8. Always call cancel functions with `defer cancel()`

### üìù Example Input/Output

**Task Definitions:**
```go
tasks := []Task{
    {ID: "task-1", Name: "Process Images", Duration: 2 * time.Second, Priority: 1},
    {ID: "task-2", Name: "Generate Report", Duration: 3 * time.Second, Priority: 2},
    {ID: "task-3", Name: "Send Emails", Duration: 7 * time.Second, Priority: 3}, // Will timeout
    {ID: "task-4", Name: "Update Database", Duration: 1 * time.Second, Priority: 1},
}
```

**Task Processing Function:**
```go
type requestIDKey struct{}

func processTask(ctx context.Context, task Task) error {
    // Extract request ID from context
    requestID, _ := ctx.Value(requestIDKey{}).(string)
    
    fmt.Printf("[%s] Starting task: %s (Priority: %d)\n", requestID, task.Name, task.Priority)
    
    // Simulate work with cancellation support
    timer := time.NewTimer(task.Duration)
    defer timer.Stop()
    
    select {
    case <-timer.C:
        fmt.Printf("[%s] ‚úÖ Completed: %s\n", requestID, task.Name)
        return nil
    case <-ctx.Done():
        fmt.Printf("[%s] ‚ùå Canceled: %s - Reason: %v\n", requestID, task.Name, ctx.Err())
        return ctx.Err()
    }
}
```

**Main Function with Context Management:**
```go
func main() {
    // Create root context with cancellation
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // Handle graceful shutdown
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-sigChan
        fmt.Println("\nüö® Shutdown signal received, canceling all tasks...")
        cancel()
    }()
    
    // Add request ID to context
    requestID := "req-" + time.Now().Format("20060102-150405")
    ctx = context.WithValue(ctx, requestIDKey{}, requestID)
    
    // Process tasks concurrently
    var wg sync.WaitGroup
    for _, task := range tasks {
        wg.Add(1)
        go func(t Task) {
            defer wg.Done()
            
            // Create task-specific timeout context (5 seconds max)
            taskCtx, taskCancel := context.WithTimeout(ctx, 5*time.Second)
            defer taskCancel()
            
            processTask(taskCtx, t)
        }(task)
    }
    
    wg.Wait()
    fmt.Println("\n‚úÖ All tasks completed or canceled")
}
```

**Program Output:**
```
[req-20251202-143022] Starting task: Process Images (Priority: 1)
[req-20251202-143022] Starting task: Update Database (Priority: 1)
[req-20251202-143022] Starting task: Generate Report (Priority: 2)
[req-20251202-143022] Starting task: Send Emails (Priority: 3)
[req-20251202-143022] ‚úÖ Completed: Update Database
[req-20251202-143022] ‚úÖ Completed: Process Images
[req-20251202-143022] ‚úÖ Completed: Generate Report
[req-20251202-143022] ‚ùå Canceled: Send Emails - Reason: context deadline exceeded

‚úÖ All tasks completed or canceled
```

**Output with Manual Cancellation (Ctrl+C after 2s):**
```
[req-20251202-143100] Starting task: Process Images (Priority: 1)
[req-20251202-143100] Starting task: Generate Report (Priority: 2)
[req-20251202-143100] Starting task: Send Emails (Priority: 3)
[req-20251202-143100] Starting task: Update Database (Priority: 1)
[req-20251202-143100] ‚úÖ Completed: Update Database

üö® Shutdown signal received, canceling all tasks...
[req-20251202-143100] ‚ùå Canceled: Process Images - Reason: context canceled
[req-20251202-143100] ‚ùå Canceled: Generate Report - Reason: context canceled
[req-20251202-143100] ‚ùå Canceled: Send Emails - Reason: context canceled

‚úÖ All tasks completed or canceled
```

### üåü Bonus Challenges

1. Add a worker pool pattern with limited concurrent tasks (max 3 workers)
2. Implement task retry logic with exponential backoff (respecting context)
3. Create a task queue with priority sorting
4. Add progress reporting (% complete) that respects cancellation
5. Implement parent-child task relationships with cascading cancellation
6. Add HTTP endpoint to trigger task processing with request context
7. Create a task dashboard showing real-time status (running/completed/canceled)
8. Implement context deadline extension for critical tasks
9. Add distributed tracing with context propagation across services
10. Create performance metrics (task duration, timeout rate, cancellation rate)

### üì§ Submission Guidelines

- Test with different task durations and timeouts
- Demonstrate graceful shutdown with Ctrl+C
- Show context deadline exceeded for slow tasks
- Include request ID in all log messages
- Share your complete code in the comments
- Explain your context hierarchy design
- Show sample output for normal and canceled scenarios
- Discuss challenges with goroutine coordination

**Looking forward to your context-aware solutions!** Share your implementation below and learn from others' approaches. üí¨

</details>

---

<h1><span style='color:#e67e22'>Conclusion</span></h1>

And there you have it! We hope this post sparked some thoughts and ideas for you. What are your own experiences or tips on this topic? We're always eager to learn from your perspective! Drop your comments, questions, or suggestions below. Your feedback helps us grow and create even better content for you. Can't wait to read what you think! üëáüòä

