---
title: "17. HTTP and Web Development"
description: "üöÄ Dive deep into HTTP and web development essentials! Master building robust web services from server basics and routing to implementing middleware and crafting efficient JSON APIs. üåê"
author: infoyouth
date: 2025-12-02 02:00:00 +0000 02:00:00 +0000
categories:
    - Programming
    - Go
    - HTTP
    - API Design
    - Server Architecture
    - Middleware
tags:
  - HTTP
  - Web Development
  - Server Architecture
  - API Development
  - Middleware
pin: true
math: false
mermaid: true
---

<!--
meta-description: "Master HTTP and web development in Go! Learn to build production-ready web servers, implement routing and middleware patterns, create RESTful JSON APIs, and make HTTP client requests with practical examples."
keywords: "Go HTTP server, net/http package, HTTP handlers, routing in Go, ServeMux, gorilla/mux, middleware pattern, RESTful API, JSON API, HTTP client, web development Go, API development, http.Handler interface"
-->

# <span style="color:#e67e22;">What we will learn in this post?</span>
<ul style='list-style-type: none; padding-left: 0;'>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>HTTP Server Basics</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>HTTP Handlers</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Routing and Multiplexers</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>HTTP Client</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Middleware Pattern</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>JSON APIs</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Conclusion!</span></li>
</ul>

# <span style="color:#e67e22">Building Your First Go HTTP Server! üöÄ</span>

Creating a basic web server in Go is surprisingly straightforward, thanks to the `net/http` package. Go's standard library provides everything you need to build production-ready HTTP servers without external dependencies. Whether you're building microservices, RESTful APIs, or web applications, understanding these fundamentals will set you on the right path. Let's get started!

## <span style="color:#2980b9">The Core Components üõ†Ô∏è</span>

Here‚Äôs how you set up a simple server:

*   **`http.HandleFunc()`**: This function is your router. It maps a URL path (like `/hello`) to a *handler function* that will process requests for that path.
*   **Handler Function**: This is a special function `func(w http.ResponseWriter, r *http.Request)`. `w` (writer) sends the response back, while `r` (request) contains details about the incoming request.
*   **`http.ListenAndServe()`**: This function starts the HTTP server. You give it the address (e.g., `":8080"` for port 8080) and optionally a handler. If `nil` is provided as the second argument, it uses the default `http.ServeMux` where your `HandleFunc` routes are registered.

### <span style="color:#8e44ad">Flowchart: How it Works üåä</span>

```mermaid
graph TD
    A["Go Program Starts"]:::style1 --> B{"http.ListenAndServe(':8080', nil)"}:::style2
    B -- "Listens on Port 8080" --> C{"Incoming Request (/hello)"}:::style3
    C -- "Matches Path" --> D["Registered Handler Function (helloHandler)"]:::style4
    D --> E["Process Request & Write Response"]:::style5
    E --> F["Send Response to Client"]:::style1
    F -- "Ready for next request" --> B

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

## <span style="color:#2980b9">"Hello, World!" Server Example üåç</span>

```go
package main

import (
	"fmt" // For printing messages
	"log" // For logging errors
	"net/http" // The core HTTP package
)

// helloHandler is our function to handle requests to "/hello"
func helloHandler(w http.ResponseWriter, r *http.Request) {
	// Write "Hello, Go Server! üëã" to the response.
	// w is where we write the data, like a browser page.
	fmt.Fprintf(w, "Hello, Go Server! üëã") 
}

func main() {
	// Register our handler for the "/hello" path.
	// When someone visits /hello, helloHandler will run.
	http.HandleFunc("/hello", helloHandler) 

	fmt.Println("Server starting on port 8080... Visit http://localhost:8080/hello")

	// Start the server and listen for incoming requests on port 8080.
	// log.Fatal will print any error and exit if the server fails to start.
	log.Fatal(http.ListenAndServe(":8080", nil)) 
}
```

*   **To Run:** Save this as `main.go`, open your terminal, navigate to the folder, and run `go run main.go`.
*   **Then Visit:** `http://localhost:8080/hello` in your web browser!

---
**Further Reading:**
*   [Go `net/http` Documentation](https://pkg.go.dev/net/http)

# <span style="color:#e67e22">Understanding Go's `http.Handler` Interface ‚ú®</span>

Go's `net/http` package is built around the `http.Handler` interface, a fundamental concept for building web services. This interface is the cornerstone of Go's HTTP ecosystem, providing a simple yet powerful abstraction that enables composable, testable, and production-ready web applications. Understanding handlers is essential for building everything from simple APIs to complex microservices architectures. It's how your Go program knows *how* to respond to incoming web requests.

---

## <span style="color:#2980b9">The `http.Handler` Interface ü§ù</span>

The `http.Handler` interface is super simple, defining just one method: `ServeHTTP`. Any *type* that implements this method can effectively *handle* an HTTP request.

*   `ServeHTTP(w http.ResponseWriter, r *http.Request)`:
    *   `w http.ResponseWriter`: This is where you send your HTTP response (like `200 OK`, custom headers, and the page content).
    *   `r *http.Request`: This contains all the details about the client's request (e.g., URL path, method like GET/POST, headers, and any data sent).

**Concept Example:**
```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

---

## <span style="color:#2980b9">`http.HandlerFunc` for Simplicity üöÄ</span>

`http.HandlerFunc` is a handy *adapter type* that lets you quickly turn a regular function into an `http.Handler`. If your handler doesn't need to store any state, casting your function to `http.HandlerFunc` is often the easiest and most common way to create a handler.

**Example (Using `http.HandlerFunc`):**
```go
import "net/http"

func greetHandler(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("Hello from a simple function!"))
}

// How you'd register it:
// http.Handle("/", http.HandlerFunc(greetHandler))
```

---

## <span style="color:#2980b9">Creating Custom Handler Types ‚öôÔ∏è</span>

When your handler needs to carry specific data or configuration (like a database connection or some settings), you can define your own `struct` and attach the `ServeHTTP` method to it. This allows your handler to be *stateful*.

**Example (Custom Handler with State):**
```go
type databaseHandler struct {
    dbConnection string // Simulating a database connection string
}

func (h *databaseHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("Connected to: " + h.dbConnection))
}

// How you'd register it:
// myDBHandler := &databaseHandler{dbConnection: "postgres://user:pass@host:port/db"}
// http.Handle("/db-info", myDBHandler)
```

---

## <span style="color:#2980b9">How Handlers Work Together üó∫Ô∏è</span>

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#ff4f81','primaryTextColor':'#fff','primaryBorderColor':'#c43e3e','lineColor':'#e67e22','secondaryColor':'#6b5bff','tertiaryColor':'#ffd700','noteBkgColor':'#00bfae','noteTextColor':'#fff'}}}%%
classDiagram
    class http_Handler{
        +ServeHTTP(w ResponseWriter, r Request)
    }
    class MyCustomHandler{
        -settings string
        -dbConnection string
        +ServeHTTP(w ResponseWriter, r Request)
    }
    class http_HandlerFunc{
        +ServeHTTP(w ResponseWriter, r Request)
    }

    http_Handler <|.. MyCustomHandler : Implements
    http_Handler <|.. http_HandlerFunc : Implements (adapter)
    
    note for http_Handler "Core interface\nfor all handlers"
    note for MyCustomHandler "Stateful handler\nwith custom data"
    note for http_HandlerFunc "Function adapter\nfor simple handlers"
```

---

**Further Reading:**
*   For deeper insights, check the official [Go `net/http` Package Documentation](https://pkg.go.dev/net/http).

# <span style="color:#e67e22">Go's HTTP Routing Explained! üõ£Ô∏è</span>

Go's built-in `net/http` package provides `http.ServeMux` for handling incoming web requests. Routing is crucial in web applications as it determines how your application responds to different URL paths and HTTP methods. While Go's standard library offers basic routing capabilities, understanding both built-in and third-party solutions helps you choose the right tool for your project's complexity. It acts like a traffic controller, directing requests to the correct *handler functions*.

## <span style="color:#2980b9">`http.ServeMux`: The Basics ‚ú®</span>

You register *handlers* (functions that process requests) for specific URL *patterns*.

### <span style="color:#8e44ad">Pattern Matching Rules üß©</span>

`ServeMux` follows simple rules:
*   It first tries to find an *exact match* (e.g., `/users`).
*   If no exact match, it looks for the *longest prefix match* that ends with `/` (e.g., `/products/` matches `/products/123`).
*   **Limitation:** `ServeMux` *doesn't support path parameters* (like `/users/123` where `123` is a dynamic ID) or *method-based routing* (e.g., handling GET vs. POST for `/users` differently). You'd have to parse URLs manually.

## <span style="color:#2980b9">Beyond `ServeMux`: Advanced Routers üöÄ</span>

For more complex routing needs, popular libraries offer powerful features:

*   **`gorilla/mux`**: Highly popular, supports path parameters (`/users/{id}`), method matching, and sub-routers.
*   **`chi`**: A lightweight, fast, and composable router, great for middleware.
*   **`httprouter`**: Focuses on performance with a tree-based routing algorithm.

These libraries excel at:
*   `Path parameters`: Easily extract dynamic parts of URLs (e.g., `id` from `/users/{id}`).
*   `Method matching`: Route requests based on HTTP methods (GET, POST, PUT, DELETE).

### <span style="color:#8e44ad">Comparison Example üí°</span>

*   **`http.ServeMux`**: To get user ID from `/users/123`, you'd match `/users/` and then *manually parse* "123".
*   **`gorilla/mux`**: `r.HandleFunc("/users/{id}", getUserHandler).Methods("GET")` ‚Äì automatically extracts `id`.

```mermaid
graph TD
    A["Client Request"]:::style1 --> B{"Go HTTP Server"}:::style2
    B -- "Simple Routes" --> C["http.ServeMux"]:::style3
    B -- "Complex Routes (Path Params, Methods)" --> D["Advanced Routers: gorilla/mux, chi, httprouter"]:::style4
    C -- "Exact / Prefix Match" --> E["Basic Handler"]:::style5
    D -- "Dynamic & Method Match" --> F["Sophisticated Handler"]:::style5

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

---
**üîó Resources for More Info:**
*   [Go `net/http` Docs](https://pkg.go.dev/net/http)
*   [Gorilla Mux GitHub](https://github.com/gorilla/mux)
*   [Chi GitHub](https://github.com/go-chi/chi)
*   [HttpRouter GitHub](https://github.com/julienschmidt/httprouter)

# <span style="color:#e67e22">Making HTTP Requests in Go üåê</span>

Go's fantastic *`net/http`* package makes interacting with web services super easy! Whether you're consuming third-party APIs, communicating between microservices, or building integration tests, Go's HTTP client capabilities are essential tools in modern development. The package provides both simple convenience functions for quick requests and powerful customization options for complex scenarios. You can effortlessly fetch data or send information using its built-in tools.

## <span style="color:#2980b9">Quick & Simple: `http.Get()` ‚ú®</span>

For basic GET requests (like loading a webpage), `http.Get()` is your best friend. It's concise and perfect for fetching resources without complex setups.

```go
package main

import (
	"fmt"
	"io"
	"net/http"
)

func main() {
	resp, err := http.Get("https://jsonplaceholder.typicode.com/todos/1")
	if err != nil {
		fmt.Printf("Error fetching URL: %v\n", err)
		return
	}
	defer resp.Body.Close() // Always close the response body!

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response body: %v\n", err)
		return
	}
	fmt.Println("GET Response:", string(body))
}
```

## <span style="color:#2980b9">Custom Requests: `http.NewRequest()` & `http.Client` üõ†Ô∏è</span>

When you need more control, like sending a `POST` request with a JSON body, setting custom headers, or using different HTTP methods (`PUT`, `DELETE`), `http.NewRequest()` is the way to go. You then use an `http.Client` to *`Do()`* the request.

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
)

func main() {
	jsonBody := []byte(`{"title": "hello", "body": "world", "userId": 1}`)
	req, err := http.NewRequest("POST", "https://jsonplaceholder.typicode.com/posts", bytes.NewBuffer(jsonBody))
	if err != nil {
		fmt.Printf("Error creating request: %v\n", err)
		return
	}
	req.Header.Set("Content-Type", "application/json") // Essential for JSON data

	client := &http.Client{} // Create a new HTTP client
	resp, err := client.Do(req) // Send the custom request
	if err != nil {
		fmt.Printf("Error sending request: %v\n", err)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response body: %v\n", err)
		return
	}
	fmt.Println("POST Response:", string(body))
}
```

### <span style="color:#8e44ad">Handling Responses & Errors üö®</span>

*   **Error Check:** Always check the `err` returned by `http.Get()` or `client.Do()`.
*   **Close Body:** Use `defer resp.Body.Close()` to ensure the network connection is properly released, preventing resource leaks.
*   **Read Body:** Use `io.ReadAll(resp.Body)` to get the server's response data.

```mermaid
graph TD
    A["Start"]:::style1 --> B{"Choose Request Type"}:::style2
    B -- "Simple GET" --> C["http.Get('URL')"]:::style3
    B -- "Custom/POST/PUT" --> D["http.NewRequest('METHOD', 'URL', Body)"]:::style4
    D --> E["Set req.Header"]:::style5
    C --> F{"Handle Error"}:::style2
    E --> G["client := &http.Client{}"]:::style3
    G --> H["resp, err := client.Do(req)"]:::style4
    C --> I["resp, err := ..."]:::style4
    H --> F
    I --> F
    F -- "Error" --> J["Log/Exit"]:::style1
    F -- "No Error" --> K["defer resp.Body.Close()"]:::style5
    K --> L["body, err := io.ReadAll(resp.Body)"]:::style3
    L --> M{"Handle Body Read Error"}:::style2
    M -- "No Error" --> N["Process Response Data"]:::style4
    N --> O["End"]:::style1
    M -- "Error" --> J
    J --> O

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">Middleware Magic in Go ü™Ñ</span>

Middleware in Go acts like a helpful *wrapper* around your main HTTP handlers. This pattern is fundamental in production web applications, enabling separation of concerns and code reusability across your entire application. Middleware handles cross-cutting concerns like logging, authentication, rate limiting, and CORS without duplicating code in every handler. Imagine it as a series of specialized steps a request takes *before* it reaches your core logic, and *after* it leaves, allowing you to add features without cluttering your core application handlers.

## <span style="color:#2980b9">What is Middleware in Go? ü§î</span>

It's essentially a function that takes an `http.Handler` (or `http.HandlerFunc`) and returns another `http.Handler`. This "wrapper" pattern lets you inject reusable logic that executes before or after your actual route handler.

### <span style="color:#8e44ad">Common Uses üöÄ</span>
*   **Logging:** `LoggingMiddleware` records request details like path and response status.
*   **Authentication:** `AuthMiddleware` verifies user credentials *before* accessing resources.
*   **CORS:** `CORSHandler` adds necessary headers for cross-origin requests.
*   **Request ID:** `RequestIDMiddleware` injects a unique ID for tracing requests across logs.

## <span style="color:#2980b9">Chaining Middleware üîó</span>

You can stack multiple middleware functions to apply logic sequentially. Each middleware processes the request, potentially modifies it, then passes it to the *next* handler in the chain until it reaches your final application logic.

```go
// A conceptual chain helper
func Chain(h http.Handler, mws ...func(http.Handler) http.Handler) http.Handler {
    for i := len(mws) - 1; i >= 0; i-- {
        h = mws[i](h)
    }
    return h
}

// Example Usage:
// http.Handle("/", Chain(myAppHandler, LoggingMiddleware, AuthMiddleware))
```

```mermaid
graph TD
    A["Incoming Request"]:::style1 --> B{"Middleware 1: Logging"}:::style2
    B --> C{"Middleware 2: Authentication"}:::style3
    C --> D{"Middleware 3: CORS"}:::style4
    D --> E["Your Actual Handler Logic"]:::style5
    E --> F["Response from Handler"]:::style5
    F --> G{"Middleware 3: Post-Processing"}:::style4
    G --> H{"Middleware 2: Post-Processing"}:::style3
    H --> I{"Middleware 1: Post-Processing"}:::style2
    I --> J["Outgoing Response"]:::style1

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

Middleware makes your Go web applications clean, modular, and highly extensible!

# <span style="color:#e67e22">Building Awesome RESTful JSON APIs üöÄ</span>
Hey there! Let's build *great web APIs* that beautifully communicate using JSON. RESTful APIs are the backbone of modern web and mobile applications, enabling seamless communication between clients and servers. By following REST principles and using JSON as the data format, you'll create APIs that are intuitive, scalable, and easy to consume by frontend applications, mobile apps, and other services. RESTful APIs rely on standard HTTP methods for clear interactions between different systems.

## <span style="color:#2980b9">Key Ingredients for Success ‚ú®</span>
For robust APIs, here's what's crucial:

*   **JSON Everywhere:** Accept request bodies and encode responses always in JSON. Clients should use `Content-Type: application/json` in headers to specify data format.
*   **HTTP Status Codes:** Be precise! Use `200 OK` for general success, `201 Created` for new resources, `400 Bad Request` for invalid input, and `500 Internal Server Error` for server-side issues.
*   **Error Handling:** Return *meaningful* JSON error messages. Include fields like `code` and `message` to guide developers on how to fix problems.

## <span style="color:#2980b9">API Endpoint Example: Creating a Product üõ†Ô∏è</span>

Imagine creating a new product.

**Endpoint:** `POST /products`

*   **Request (with `Content-Type: application/json` header):**
    ```json
    {
      "name": "Super Widget",
      "price": 29.99
    }
    ```

*   **Successful Response (Status: `201 Created`):**
    ```json
    {
      "id": "prod-123",
      "name": "Super Widget",
      "price": 29.99
    }
    ```
    *If errors occur (e.g., missing data), a `400 Bad Request` with a descriptive JSON error message is returned.*

### <span style="color:#8e44ad">How It Flows & More Info üí°</span>

Here‚Äôs a simple interaction:

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#ff4f81','primaryTextColor':'#fff','primaryBorderColor':'#c43e3e','lineColor':'#e67e22','secondaryColor':'#6b5bff','tertiaryColor':'#ffd700','noteBkgColor':'#00bfae','noteTextColor':'#fff'}}}%%
sequenceDiagram
    participant Client as üì± Client
    participant Server as üñ•Ô∏è Server
    
    Note over Client,Server: RESTful API Interaction
    Client->>+Server: POST /products (JSON Request)
    Note right of Server: Validate & Create Resource
    Server->>Server: Process JSON data
    Server-->>-Client: 201 Created (JSON Response)
    Note left of Client: New product created ‚úÖ
```
---

## <span style="color:#ffd700">üéØ Hands-On Assignment</span>

<details>
<summary><strong>üí° Project: Task Management API</strong> (Click to expand)</summary>
<br>
<p><strong>üöÄ Your Challenge:</strong></p>
<p>Build a <strong>Task Management RESTful API</strong> with full CRUD operations, middleware, and proper error handling. Your API should support creating, reading, updating, and deleting tasks with authentication. üåêüîê</p>

<p><strong>üìã Requirements:</strong></p>
<p>Create an HTTP server with these features:</p>

<p><strong>1. Task struct:</strong></p>
<ul>
<li><code>ID</code> (string, auto-generated)</li>
<li><code>Title</code> (string, required)</li>
<li><code>Description</code> (string)</li>
<li><code>Status</code> (string: "pending", "in-progress", "completed")</li>
<li><code>CreatedAt</code> (time.Time)</li>
<li><code>UpdatedAt</code> (time.Time)</li>
</ul>

<p><strong>2. API Endpoints:</strong></p>
<ul>
<li><code>POST /api/tasks</code> - Create new task</li>
<li><code>GET /api/tasks</code> - List all tasks</li>
<li><code>GET /api/tasks/{id}</code> - Get specific task</li>
<li><code>PUT /api/tasks/{id}</code> - Update task</li>
<li><code>DELETE /api/tasks/{id}</code> - Delete task</li>
</ul>

<p><strong>3. Middleware:</strong></p>
<ul>
<li>Logging middleware (log all requests with method, path, duration)</li>
<li>Authentication middleware (check for <code>X-API-Key</code> header)</li>
<li>CORS middleware (allow cross-origin requests)</li>
</ul>

<p><strong>4. Error Handling:</strong></p>
<ul>
<li>Return proper HTTP status codes</li>
<li>JSON error responses with <code>error</code> and <code>message</code> fields</li>
</ul>

<p><strong>üí° Implementation Hints:</strong></p>
<ul>
<li>Use <code>gorilla/mux</code> or <code>chi</code> for routing with path parameters üõ£Ô∏è</li>
<li>Store tasks in-memory using a <code>map[string]Task</code> with mutex for thread-safety</li>
<li>Generate unique IDs using <code>uuid</code> package or simple counter</li>
<li>Validate required fields before creating/updating</li>
<li>Chain multiple middleware functions</li>
<li>Use <code>encoding/json</code> for request/response bodies</li>
<li>Handle invalid JSON and missing resources gracefully</li>
</ul>

<p><strong>Example Input/Output:</strong></p>
<p><strong>Create Task Request:</strong></p>
<pre>
curl -X POST http://localhost:8080/api/tasks \
  -H "Content-Type: application/json" \
  -H "X-API-Key: secret123" \
  -d '{"title": "Learn Go", "description": "Complete HTTP tutorial"}'
</pre>

<p><strong>Success Response (201 Created):</strong></p>
<pre>
{
  "id": "task-001",
  "title": "Learn Go",
  "description": "Complete HTTP tutorial",
  "status": "pending",
  "created_at": "2025-12-02T10:30:00Z",
  "updated_at": "2025-12-02T10:30:00Z"
}
</pre>

<p><strong>List Tasks Response (200 OK):</strong></p>
<pre>
{
  "tasks": [
    {
      "id": "task-001",
      "title": "Learn Go",
      "status": "pending"
    },
    {
      "id": "task-002",
      "title": "Build API",
      "status": "in-progress"
    }
  ],
  "count": 2
}
</pre>

<p><strong>Error Response (401 Unauthorized):</strong></p>
<pre>
{
  "error": "unauthorized",
  "message": "Missing or invalid API key"
}
</pre>

<p><strong>Server Log Output:</strong></p>
<pre>
[2025-12-02 10:30:00] POST /api/tasks - 201 Created - 5ms
[2025-12-02 10:30:15] GET /api/tasks - 200 OK - 1ms
[2025-12-02 10:30:30] PUT /api/tasks/task-001 - 200 OK - 3ms
</pre>

<p><strong>üåü Bonus Challenges:</strong></p>
<ul>
<li>Add query parameters for filtering tasks by status: <code>GET /api/tasks?status=pending</code> üîç</li>
<li>Implement pagination: <code>GET /api/tasks?page=1&limit=10</code></li>
<li>Add task search: <code>GET /api/tasks/search?q=learn</code></li>
<li>Support partial updates with <code>PATCH /api/tasks/{id}</code></li>
<li>Add rate limiting middleware (max 10 requests per minute)</li>
<li>Implement graceful shutdown with <code>signal.Notify</code></li>
<li>Add request timeout middleware (max 5 seconds per request)</li>
<li>Create OpenAPI/Swagger documentation</li>
</ul>

<p><strong>Submission Guidelines:</strong></p>
<ul>
<li>Test all endpoints with curl or Postman</li>
<li>Include examples of successful and error responses</li>
<li>Share your complete code in the comments</li>
<li>Explain your middleware design decisions</li>
<li>Show server logs demonstrating request flow</li>
<li>Discuss any challenges you encountered</li>
</ul>

<p><strong>Share Your Solution! üí¨</strong></p>
<p>Excited to see your RESTful APIs! <strong>Post your implementation below</strong> and let's learn from each other's approaches. üé®</p>

</details>

---

<h1><span style='color:#e67e22'>Conclusion</span></h1>
And there we have it! Thanks so much for joining me today. I truly hope you found this post helpful or at least a little bit interesting. What are your own thoughts on this topic? Do you have any experiences, tips, or even suggestions you'd like to share? I'm all ears! Please, don't be shy ‚Äì drop your comments, feedback, or questions down below. Let's keep the conversation going! üëáüí¨ I can't wait to read what you think. üòä

