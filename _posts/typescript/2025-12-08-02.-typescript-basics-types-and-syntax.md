---
title: "02. TypeScript Basics - Types and Syntax"
description: "üéØ Master TypeScript's type system! Learn primitive types, arrays, tuples, enums, type assertions, union/intersection types, and literal types with practical examples."
author: infoyouth
date: 2025-12-08 02:00:00 +0000
categories:
  - Programming
  - TypeScript
  - Web Development
  - Type System
tags:
  - TypeScript
  - Types
  - Type Safety
  - Enums
  - Tuples
  - Union Types
  - Type Aliases
pin: true
math: false
mermaid: true
---

<!--
meta-description: Master TypeScript's type system from the ground up! This comprehensive guide covers primitive types, arrays, tuples, enums, type assertions, union and intersection types, literal types, and type aliases with practical examples and best practices.
keywords: TypeScript types, TypeScript basics, primitive types, arrays and tuples, TypeScript enums, type assertions, union types, intersection types, literal types, type aliases, type guards, type narrowing, TypeScript syntax
-->

# <span style="color:#e67e22;">What we will learn in this post?</span>
<ul style='list-style-type: none; padding-left: 0;'>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Basic TypeScript Types</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Type Inference in TypeScript</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Arrays and Tuples</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Enums in TypeScript</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Type Assertions and Type Casting</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Union and Intersection Types</span></li>
<li><span style='color: #2980b9; font-size: 20px; font-weight: bold;'>üëâ</span> <span style='color: #2ecc71; font-size: 18px; font-weight: bold;'>Literal Types and Type Aliases</span></li>
</ul>

# <span style="color:#e67e22">Welcome to TypeScript's Basic Types! üßë‚Äçüíª</span>

TypeScript adds *type safety* to JavaScript, helping you catch errors early and write more robust code. Let's explore its fundamental types!

## <span style="color:#2980b9">The Everyday Essentials ‚ú®</span>

These are your go-to types for common data:

### <span style="color:#8e44ad">Number üî¢</span>
For *any* numeric value, whether whole (`integer`) or decimal (`float`).
```typescript
let age: number = 30;
let price: number = 19.99; // Use for quantities, costs, etc.
```

### <span style="color:#8e44ad">String üìù</span>
For text! Enclose content in single (`''`), double (`""`), or backticks (`` ``) for template literals.
```typescript
let username: string = "Alice";
let greeting: string = `Hello, ${username}!`; // For names, messages, descriptions.
```

### <span style="color:#8e44ad">Boolean ‚úÖ</span>
For simple true/false values, perfect for logical checks or flags.
```typescript
let isActive: boolean = true;
let hasPermission: boolean = false; // For toggles, status indicators.
```

## <span style="color:#2980b9">Special Mentions üí°</span>

### <span style="color:#8e44ad">Null & Undefined üëª</span>
These represent an *absence* of a value. `null` is an *intentional* absence, while `undefined` means a variable hasn't been assigned anything yet.
```typescript
let data: string | null = null; // Data might be absent.
let notAssigned: string | undefined; // Defaults to undefined if not initialized.
```

### <span style="color:#8e44ad">Void üö´</span>
Used for functions that *don't return any value*. They just perform an action.
```typescript
function logMessage(msg: string): void {
  console.log(msg); // This function logs, but returns nothing.
}
```

## <span style="color:#2980b9">Flexibility vs. Safety: Any vs. Unknown üöß</span>

### <span style="color:#8e44ad">Any (The Wildcard) üÉè</span>
Bypasses *all* type checking. Use `any` *sparingly* when you truly don't know the type, or are migrating legacy JavaScript. It turns off TypeScript's safety net.
```typescript
let whatever: any = "hello";
whatever = 123; // No error! (TypeScript doesn't check)
whatever.toUpperCase(); // Possible runtime error if 'whatever' is 123
```

### <span style="color:#8e44ad">Unknown (The Safer Wildcard) ‚ùì</span>
Like `any`, `unknown` can hold any value, but TypeScript *forces* you to narrow its type (check what it is) before performing operations. This promotes type safety.
```typescript
let mystery: unknown = "secret";
// mystery.toUpperCase(); // Error: Object is of type 'unknown'.
if (typeof mystery === 'string') {
  console.log(mystery.toUpperCase()); // OK, type narrowed to string
}
```

**When to choose:**
*   `any`: *Avoid* if possible. Use for quick fixes or deeply dynamic data that's hard to type.
*   `unknown`: *Prefer* for values coming from external sources (APIs, user input) where the exact type isn't guaranteed. It forces explicit, safe type checks.

```mermaid
graph TD
    A["üöÄ Need to Handle Any Value?"]:::style1 -->|"‚úÖ Yes"| B{"Prioritize Type Safety?"}:::style3
    B -->|"‚úÖ Yes, strongly (recommended)"| C["üõ°Ô∏è Use 'unknown'"]:::style4
    B -->|"‚ùå No (legacy code, quick hack)"| D["üÉè Use 'any'"]:::style7
    A -->|"‚ùå No (Know the value's type)"| E["üéØ Use Specific Type (number, string, etc.)"]:::style6

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style6 fill:#43e97b,stroke:#38f9d7,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style7 fill:#9e9e9e,stroke:#616161,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">TypeScript Arrays & Tuples: Your Data Squad! üöÄ</span>

Let's make our data lists super organized with TypeScript! It helps us know exactly what's inside.

## <span style="color:#2980b9">Basic Arrays: Organized Lists ‚ú®</span>
TypeScript lets you specify what type of items an array holds. For numbers, use `number[]` or `Array<number>`. For strings, `string[]` or `Array<string>`.

*   *Example:* `let scores: number[] = [85, 92, 78];`

## <span style="color:#2980b9">Multi-dimensional Arrays: Arrays of Arrays üó∫Ô∏è</span>
Need arrays within arrays, like a grid? Just add more `[]` to your type!

*   *Example:* `let matrix: number[][] = [[1, 2], [3, 4]];`

## <span style="color:#2980b9">Tuples: Fixed-Length, Mixed Types ü§ù</span>
Tuples are special arrays with a *fixed number* of elements, where each position has a *specific, known type*. Great for profiles or coordinates!

*   *Example:* `let userProfile: [string, number, boolean] = ["Alice", 30, true];`
    *   *Here, `userProfile` must have exactly three elements: a string, then a number, then a boolean.*

## <span style="color:#2980b9">Readonly Arrays: Immutable Data üîí</span>
To ensure an array's contents can't be changed after creation, use the `readonly` keyword.

*   *Example:* `let fixedNumbers: readonly number[] = [10, 20];`
    *   `fixedNumbers.push(30);` // ‚ùå *Error! You can't modify a readonly array.*

## <span style="color:#2980b9">Array Methods: Business as Usual üõ†Ô∏è</span>
Standard JavaScript array methods like `.push()`, `.map()`, and `.filter()` work just as you'd expect, respecting all your TypeScript types!

*   *Example:* `scores.push(95);` // ‚úÖ *Valid, as `scores` is an array of numbers.*

```mermaid
graph TD
    A["üìä Data Lists"]:::style1 --> B["üì¶ Arrays"]:::style2
    A --> C["üéØ Tuples"]:::style4
    B -- "Same Type" --> B1["üî¢ number[]"]:::style5
    B -- "Multi-dim" --> B2["üìù string[][]"]:::style6
    C -- "Fixed Length, Mixed Types" --> C1["ü§ù [string, number, boolean]"]:::style3

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style6 fill:#43e97b,stroke:#38f9d7,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

# <span style="color:#e67e22">TypeScript Enums: Your Constant Companions ü§ù</span>

Need to represent a fixed set of meaningful values like `North` or `Pending` clearly? TypeScript *Enums* (`enum`) are perfect! They let you define named constants, making your code super readable and reducing errors from "magic numbers" or hardcoded strings. Think of them as a way to give names to numbers or strings that have special meaning.

## <span style="color:#2980b9">Enum Types & Purpose üí°</span>

Enums boost readability and provide type safety. Here are the common kinds:

*   **Numeric Enums:** Assign numerical values (defaulting `0`, `1`, etc. if not specified). Great for status codes or directions.
    ```typescript
    enum Direction { North, East, South } // North is 0, East is 1
    let myWay: Direction = Direction.North;
    ```
*   **String Enums:** Use actual readable string values. Very useful for API responses or logging categories.
    ```typescript
    enum Status { Pending = "PENDING", Approved = "APPROVED" }
    let orderStatus: Status = Status.Approved;
    ```
*   **Heterogeneous Enums:** A mix of numeric and string members (less common, but possible).
    ```typescript
    enum Mixed { No = 0, Yes = "YES" }
    ```

## <span style="color:#2980b9">Compilation & Const Enums ‚ú®</span>

When TypeScript compiles, regular enums typically become *JavaScript objects*, allowing you to access both the name from the value and vice-versa. This offers flexibility but adds minor runtime overhead.

### <span style="color:#8e44ad">Optimize with `const enum` üöÄ</span>

For maximum performance, use `const enum`. These completely disappear at compile time, replaced directly by their literal values in the JavaScript output. They're ideal when enum values are known *before* runtime, like `Direction.North` becoming `0`. This makes your JavaScript leaner and faster!

```typescript
const enum LogLevel { DEBUG, INFO }
console.log(LogLevel.INFO); // Compiles to console.log(1);
```


# <span style="color:#e67e22">TypeScript Type Assertions: Your Guiding Hand! üëã</span>

Sometimes, *you* know a variable's type better than TypeScript. Assertions tell the compiler, "Trust me!" They're **compile-time hints**, **not** runtime conversions.

## <span style="color:#2980b9">Two Ways to Assert! ‚ú®</span>

You can use:
*   **Angle-Bracket:** `<string>myVar`
*   **`as` Syntax:** `myVar as string` (preferred, especially in JSX).
    *   *Example:* `let val: any = "text"; let len = (val as string).length;`

## <span style="color:#2980b9">Assertion ‚â† Conversion! üí°</span>

Assertions **don't change data**. `(someValue as number)` won't convert `"5"` to `5`. It just tells TS how to *treat* it. If `someValue` is a `string` but asserted as `number`, you risk a runtime error using `number` methods.

## <span style="color:#2980b9">The "I'm Sure it's Not Null!" Operator `!` üõ°Ô∏è</span>

The non-null assertion `!` tells TypeScript: "This value isn't `null` or `undefined`."
*   *Example:* `document.getElementById('id')!.value`. Use *only* when certain, as it bypasses critical null safety checks.

## <span style="color:#2980b9">When & How to Assert Wisely ü§î</span>

Use sparingly when TypeScript can't infer correctly (e.g., `document.getElementById`) or with `any` types. **Best Practice:** Only when *absolutely certain* of the type. `as Type` is generally favored. Overuse hides potential bugs.

# <span style="color:#e67e22">Understanding Union & Intersection Types in TypeScript ‚ú®</span>

TypeScript helps us define variable types precisely. But what if a variable can be *one of several* types, or needs *all properties* from multiple types? Let's explore!

---

## <span style="color:#2980b9">Union Types: "OR" Logic üß©</span>

A variable can be *either* `Type1` *or* `Type2`. We use the pipe symbol (`|`) to define them.

*   **How it works:** `let id: number | string;` means `id` can hold a `number` *or* a `string`.
*   **Why use it:** Great for flexible data, like an ID that might be numeric or text.

---

## <span style="color:#2980b9">Intersection Types: "AND" Logic ü§ù</span>

Intersection types combine *all* properties from `Type1` *and* `Type2` into a single new type. We use the ampersand symbol (`&`).

*   **How it works:** `type FullUser = User & Permissions;` creates a `FullUser` with *all* properties from `User` *and* `Permissions`.
*   **Why use it:** Useful for combining functionalities or merging object shapes.

---

## <span style="color:#2980b9">Type Guards & Narrowing: Staying Safe! üõ°Ô∏è</span>

When using union types, TypeScript needs to *know* the specific type at runtime. This process is called ***narrowing***. We achieve this using ***type guards***. A common guard is the `typeof` operator.

*   **How it works:** `typeof` checks a variable's type, intelligently *narrowing* it within a code block. This allows safe access to type-specific methods.

```typescript
function processId(input: number | string) {
  if (typeof input === "string") {
    console.log(input.toUpperCase()); // input is now 'string'
  } else {
    console.log(input.toFixed(2)); // input is now 'number'
  }
}
```

```mermaid
graph TD
    A["üöÄ Start: Variable with Union Type (number | string)"]:::style1 --> B{"üõ°Ô∏è Use Type Guard (typeof)?"}:::style3
    B -- "‚úÖ Yes, typeof === string" --> C["üìù Type Narrowed to string"]:::style4
    B -- "‚ùå No, else" --> D["üî¢ Type Narrowed to number"]:::style5
    C --> E["‚úÖ Safely use string methods"]:::style6
    D --> F["‚úÖ Safely use number methods"]:::style6
    E --> G["üèÅ End: Type-safe operation"]:::style2
    F --> G

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style6 fill:#43e97b,stroke:#38f9d7,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

---

### <span style="color:#8e44ad">Practical Applications üí°</span>

*   **Unions:**
    *   Handling diverse API responses (e.g., `SuccessData | ErrorData`).
    *   Defining flexible component props that accept different data types.
*   **Intersections:**
    *   Creating complex objects by merging simpler types.
    *   Implementing mixins for shared functionalities.

---
For more info: [TypeScript Handbook - Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)

# <span style="color:#e67e22">Super Specific Types & Nicknames! üéØ</span>

Ever need a type that's *exactly* a certain value, not just any `string` or `number`? That's where **literal types** come in! Instead of `string`, you can say `let x: 'hello' | 'world'`, meaning `x` can *only* be the string `"hello"` or `"world"`. It's like a very specific menu!

Here are some examples:

*   **String Literals**: `let color: 'red' | 'blue';` üü• (Can only be 'red' or 'blue')
*   **Numeric Literals**: `let level: 1 | 2 | 3;` üî¢ (Can only be 1, 2, or 3)

---

## <span style="color:#2980b9">Type Aliases: Your Code's Nickname Generator! üè∑Ô∏è</span>

When types get a bit long or complex, **type aliases** (`type` keyword) are your best friend! They let you create a friendly custom name for *any* type definition. It makes your code much cleaner and easier to read.

*   `type UserID = string | number;`
*   Now, instead of writing `string | number` repeatedly, you can just use `UserID`.

---

### <span style="color:#8e44ad">Combining Them for Super Clarity! ü§ù</span>

Mixing literal types with type aliases makes your code incredibly readable and maintainable! You can give a simple name to a set of exact values.

Let's define allowed directions for a game:

```typescript
type Direction = 'north' | 'south' | 'east' | 'west';
let playerMovement: Direction = 'east'; // This is valid!
// playerMovement = 'up'; // ‚ùå Error! 'up' isn't a valid Direction.
```

This clearly states what values `playerMovement` can hold.

```mermaid
graph LR
    A["üéØ Literal Types"]:::style1 --"Define Exact Values"--> B["üí° e.g., 'on' | 'off'"]:::style3
    C["üè∑Ô∏è Type Aliases"]:::style4 --"Give Custom Names"--> D["üìù e.g., type Status = ..."]:::style5
    B --"Combined for Clarity"--> E["‚ú® type ToggleStatus = 'on' | 'off'"]:::style6
    D --"Makes Code More Readable"--> E

    classDef style1 fill:#ff4f81,stroke:#c43e3e,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style2 fill:#6b5bff,stroke:#4a3f6b,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style3 fill:#ffd700,stroke:#d99120,color:#222,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style4 fill:#00bfae,stroke:#005f99,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style5 fill:#ff9800,stroke:#f57c00,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;
    classDef style6 fill:#43e97b,stroke:#38f9d7,color:#fff,font-size:16px,stroke-width:3px,rx:14,shadow:6px;

    linkStyle default stroke:#e67e22,stroke-width:3px;
```

For more details, check out the [TypeScript Handbook on Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types) and [Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases).

---

---

# <span style="color:#e67e22">üéì Conclusion</span>

Congratulations on mastering TypeScript's type system! You've learned how to leverage primitive types, arrays, tuples, enums, and advanced features like union/intersection types and type aliases to write safer, more maintainable code. By understanding type guards and narrowing, you can now handle dynamic data confidently while maintaining TypeScript's compile-time safety guarantees. These fundamentals form the foundation for building robust applications with TypeScript.

---

